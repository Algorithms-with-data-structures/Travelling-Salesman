# Traveling Salesman Problem (TSP) Solver

This repository contains a C++ implementation of a solver for the **Traveling Salesman Problem (TSP)**. The program computes the optimal path and its cost for a salesman to visit all nodes (cities) in a graph exactly once and return to the starting node. The implementation uses an exhaustive approach to generate and evaluate possible paths.

## Table of Contents
- [Introduction](#introduction)
- [Problem Description](#problem-description)
- [Features](#features)
- [Input File Format](#input-file-format)
- [How to Use](#how-to-use)
  - [Compiling and Running](#compiling-and-running)
  - [Program Options](#program-options)
- [Algorithm Details](#algorithm-details)
- [Performance](#performance)
- [Limitations](#limitations)

## Introduction
The **Traveling Salesman Problem (TSP)** is a classic combinatorial optimization problem. Given a set of nodes (cities) and the costs of traveling between them, the goal is to find the shortest possible path that visits each node exactly once and returns to the starting node.

This program reads the adjacency matrix of a graph from a file or generates one randomly and solves the problem using exhaustive path generation.

## Problem Description
- **Input:**
  - A weighted graph represented as an adjacency matrix.
  - Costs between nodes (travel distances or times).
- **Output:**
  - The optimal path that minimizes the total cost.
  - The total cost of the path.

## Features
- Reads graph adjacency matrix from a file.
- Generates and evaluates all possible paths.
- Displays each level of path generation.
- Reconstructs and displays the optimal path and its cost.

## Input File Format
The program reads the graph from a file with the following format:
1. The first line contains the number of nodes in the graph.
2. The subsequent lines contain the adjacency matrix (space-separated integers representing the cost of traveling between nodes).

### Example Input File (`graph1.txt`):
```
4
0 7 12 17
2 0 6 7
3 10 0 9
5 7 5 0
```

- **`0`** indicates no cost (self-loops).
- Costs between nodes are positive integers.

## How to Use
### Compiling and Running
1. **Clone the Repository:**
   ```bash
   git clone <repository-url>
   cd <repository-directory>
   ```

2. **Compile the Code:**
   Use a C++ compiler to build the program:
   ```bash
   g++ -o tsp_solver tsp.cpp
   ```

3. **Run the Program:**
   ```bash
   ./tsp_solver
   ```

### Program Options
Upon running the program, you can choose from the following options:

1. **Read Matrix:** Load an adjacency matrix from a file.
2. **Solve the Traveling Salesman Problem:** Compute the optimal path and cost.
3. **Display Generated Levels:** Show the paths generated at each level.
4. **Reconstruct the Path:** Display the optimal path and its cost.
5. **Exit:** Exit the program.

## Algorithm Details
The implementation uses the following approach:

1. **Path Representation:**
   - A path is represented as a structure containing the start node, end node, cost, and visited nodes.

2. **Path Generation:**
   - Starting from the first node, paths to other nodes are generated iteratively.
   - At each level, new paths are generated by extending paths from the previous level.

3. **Cost Calculation:**
   - The cost of each path is calculated by summing the costs of the edges along the path.

4. **Optimal Path Selection:**
   - Redundant paths with higher costs are removed.
   - The path with the lowest cost at the final level is selected as the optimal solution.

5. **Path Reconstruction:**
   - The optimal path is reconstructed by tracing back through the levels.

## Performance
The execution time of the algorithm is displayed after solving the problem. However, this exhaustive approach is computationally expensive and is best suited for small graphs due to factorial growth in complexity.

## Limitations
- This implementation does not scale well for large graphs because it evaluates all possible paths.
- Negative edge weights are not supported.
- Input validation is minimal.

